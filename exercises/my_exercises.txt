=== Exercise A1 ===

For our first exercise, the goal is to get comfortable with the workflow of 
running xky applications on the boards connected to our server (Phantom).

When a board is powered up, it is programmed to try a TFTP boot. What this means
is that when it is powered on, it will look for a file with a specific name on
the TFPT server at 192.168.0.2 and it will boot this file.

For this exercise, you should not concern yourself with the application being 
loaded. We simply want to look at the serial output of our boards, and them
perform a power cycle so that the binary is booted by the board, and we can see
the output

1. Run "screen /opt/shortc/<your_board_name> 115200"
2. While maintaining the first terminal window open, run "ima_powerctrl cycle <your_power_line_number>"
3. What do you see on the serial output window?



Additionally: Try editing a file in phantom


=== Exercise A ===

Build the absolute simplest XKY app:
 - single partition
 - code is just printing "Hello World"

It's important to start from scratch and show what is part of an XKY app.
The XML files and their parts. Other apps will be based on this one.

1. Create the necessary files, but leave them empty
2. Write the XML file for the application
3. Write the XML file for the partition
4. Write the C code with "hello world"


=== Exercise 0 ===

This exercise includes:
 - printing text
 - using several partitions
 - mtf events stuff
 - partition running times
 - schedules

1. Implement a very simple XKY application. It should only print some text and then
exit. It will have a single partition.
2. Implement the same application, but now printing a message in two partitions. 
3. Now change the functions so that the prints run on endless loops. 
4. Now make each print once every MTF. Use the function wait_in_next_mtf.
5. Now make partitions take half as long a time to run
6. Now add a third partition, making partitions run as 1 2 3 1 2 3.
7. Change the schedule to run as 1 2 1 3 1 2 1 3


=== Exercise 01 ===

In this exercise, we will be learning how to run a simple application on our setup.

1. Start by compiling the XKY application
2. Move the application to the TFTP server
3. See what is happening with your board, running the screen command
4. Run the powerctlr cycle command with your power line so that the board reboots
5. Exit screen :^)

=== Exercise 1 ===

This exercise is about partitions information. It is

Some functions you should use durig this exercise:
 - get_partition_id
 - get_partition_status
 - set_partition_mode
 - permissions on accessing other partition mode and status

1. Print the partition id of two partitions
2. Print the partition status of two partitions, with the things it contains
3. Using set_partition_mode and then checking the status again, some exercise about
this, still not completely clear how I would do it.


=== Exercise 2 ===

In this exercise, we will be using XKY's functions to get information about the
current schedule

Functions to be used:
 - get_schedule_id
 - get_schedule_status
 - set_module_schedule
 - permissions on changing the module schedule

1. Print the schedule id of two partitions
2. Print the schedule status of two partitions, with the things it contains
3. Using set_module_schedule and then checking the schedule status again, some 
exercise about this, still not completely clear how I would do it.


=== Exercise 2 ===

On the Readme:
      scheduling events without polling the schedule status 
      does the same of the previous module but using events (similar timings)

Don't know too well where to go from here still


=== Exercise 3 ===

On the README:
      partition timers
      diferent timer expiration per partition
      timer events

1. Start a time and watch it run out as it prints
2. Some other thing to do with timers


=== Exercise 5 ===

Exercise about Queuing ports
      port status
      read/write queuing ports and message status
      port flush

1.Declare queing port
2. Print port status
3. Send messages across a queuing port
4. Flush port


=== Exercise 6 ===

Exercise about Queuing ports
      port status
      read/write samplind ports and message status

1. Declare sampling port
2. Print port status
3. Send messages across a sampling port


=== Exercise 7 ===

Exercises about memory

On README.
 - memory regions
 - memory status
 - shared memory

1. Create proper memories, shared memory between two partitions
2. Check memory regions you have
3. Send message across shared memory regions
4. Now send another, larger message that makes you have to increase memory size.


=== Exercise 8 ===

Exercises about events

enable_port_activity_irq


    /* enable port activity IRQ */
    bare_isr_install_handler(XKY_IRQ_PORT_ACTIVITY, (bare_isr_handler_f)port_activity);