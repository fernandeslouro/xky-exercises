
=== Exercises to add ===

 - Related to permissions/changes in permissions
 - Partition lifecycle (cold, warm, etc)
 - Exercise to test limits

=== Exercise A ===

For our first exercise, the goal is to get comfortable with the workflow of 
running xky applications on the boards connected to our server (Phantom).

When a board is powered up, it is programmed to try a TFTP boot. What this means
is that when it is powered on, it will look for a file with a specific name on
the TFPT server at 192.168.0.2 and it will boot this file.

For this exercise, you should not concern yourself with the application being 
loaded. We simply want to look at the serial output of our boards, and them
perform a power cycle so that the binary is booted by the board, and we can see
the output

1. Run "screen /opt/shortc/<your_board_name> 115200"
2. While maintaining the first terminal window open, run 
      "ima_powerctrl cycle <your_power_line_number>"
3. What do you see on the serial output window?

Additionally: Try editing a file in phantom


=== Exercise B ===

In the previous exercise, we ran a previously compiled application on a boards,
which was already placed on the TFTP server. Now, we will be learning the whole
flow, from compiling an application, moving it to the tftp server, and rebooting
the board, so that it boots the new app in the tftp server.

1. Start by compiling the XKY application
2. Move the application to the TFTP server
3. See what is happening with your board, running the screen command
4. Run the powerctlr cycle command with your power line so that the board reboots
5. Exit screen :^)


=== Exercise C ===

So far, we have only compiled applications we did not write. In this exercise, we
want to build a very simple XKY application. This app should have a single partition,
which only prints "Hello World!" and then if should exit. 

You should start writing this application based on the boilerplate code in the
folder "boilerplate app". Other apps we will write on this course will all be
based on this one.

1. Create the necessary files, but leave them empty
2. Write the XML file for the application
3. Write the XML file for the partition
4. Write the C code with "hello world"


=== Exercise D ===

We now want to develop a slightly more complex application. The questions below
will guide you through developing an application of increasing complexity, 
while introducing you to the use of different XKY concepts.

Introduced concepts:
 - using several partitions

1. Implement the same application, but now printing a message in two partitions. 
2. Now change the functions so that the prints run on endless loops. 


=== Exercise E ===

What if we don't want to run the prints this many times, but we still want them 
to run in every schedule? XKY has this capablity

Introduced concepts:
 - mtf events stuff
 - partition running times

1. Now make each print once every MTF. Use the function wait_in_next_mtf.
2. Now make partitions take half as long a time to run
3. Some more complex stuff with MTFs


=== Exercise F ===

To add some complexity, we now want do implement an application with 3 partitions,
and a different schedule. You could implement this as a singe schedule, but in 
this exercise you should implement it as two schedules.

Introduced concepts:
 - schedules

1. Now add a third partition, making partitions run as 1 2 3 1 2 3.
2. Change the schedule to run as 1 2 1 3 1 2 1 3


=== Exercise G (MODULE_0) ===

This exercise is about accessing information about partitions, as well
as changing the current state of partitions. YOu should figure out how to 
implement the sequence below, making use of the concepts introduced in previous 
exercises and the new functions.

Some functions you should use during this exercise:
 - get_partition_id
 - get_partition_status
 - set_partition_mode
 - bare_wake_next_mtf
 - permissions on accessing other partition mode and status

Impement the following sequence of commands:
 - ts1 P1 Gets is own ID and Status and print it
 - ts2 P2 Gets is own ID and Status and print it
 - ts3 P1 Gets P2 ID and status and print it
 - ts4 P2 Gets P1 ID and status and print it
 - ts5 P1 Sets P2 to IDLE, prints P2 status, and the set is own state to IDLE
 - Both partitions should be stopped


=== Exercise H (MODULE_1) ===

In this exercise, we will be using XKY's functions to get information about the
current schedule

This exercise has some similarities to the precious one, but focuses on XKY's 
functions related to schedules, while the previous one focused on partition-related 
functions. Implement the sequence below.

Functions to be used:
 - get_schedule_id
 - get_schedule_status
 - set_module_schedule
 - set_schedule
 - permissions on changing the module schedule

Easy:
 - just run get_schedule_id and get_schedule status

Implement:
 - P1 from time window to time window changes what it does using bare_wake_in_next_mtf
	1. Prints schedule ID (though: should also add schedule_status, check feasibility)
	2. Changes schedule 
 - P2 and P3 Prints schedule ID 


=== Exercise I (MODULE_2) ===

Functions to use:
 - bare_isr_handler_f
 - bare_isr_install_handler

On the Readme:
      scheduling events without polling the schedule status 
      does the same of the previous module but using events (similar timings)

Implement:
 - Change the preview example to use events instead of the bare_wake_in_next_mtf


=== Exercise J (MODULE_4) ===

Functions to use:
 - get_elapsed_time

We'll now implement some code which makes use of XKY's timer capabilities. 

Implement:
 - Implement two partitions, which print the global and local elapsed time, every 
time the partition runs


=== Exercise K (MODULE_3) ===

This is a more complex timers exercise. Instead of getting the elapsed time, we
are now using timers, as well as timer evets.   

Functions to use:
 - get_timer_tps
 - start_timer

On the README:
      partition timers
      diferent timer expiration per partition
      timer events

Implement:
 - Set 4 Different timers for each partition, that will trigger an event that 
 will print Global time , Local Time and the information of which timer was reached 


=== Exercise L (MODULE_5) ===

So far, all the exercises we have solved have involved partitions which run 
independently of each other. In this exercise, we will learn about XKY's inter-
partition communication functions. We'll start with queuing ports.

TODO: Make sure the exercise specifically makes use of flush_port

Functions to use:
 - get_port_id
 - get_port_status
 - flush_port
 - read_port
 - write_port

Implement:
 - P1 initially gets port ID, and prints the port status, after that, : 
	1. Sends a number of messages less than MaxNbMessages
	2. Sends a message smaller than MaxMessageSize
 - P2 initially gets port ID, and prints the port status, after that, each time window :
	1. Read all words on port and checks if is overflowed
	2. Read message and check if the message size overflowed
And then:
 - Now change the partition P1 to
	1. Sends more messages than MaxNbMessages
	2. Sends a message larger than MaxMessageSize
 - Verify that the previous verifications at P2 are working properly


=== Exercise M (MODULE_6) ===

The other type of ports in XKY are sampling ports. This exercise is based on the
previous one.

Implement:
 - Change the previous example to use sampling ports. Check the validity of the 
read message


=== Exercise N ===

(WIP)
Exercises about memory. For thse, I probably won't go through what we have in
the memory_permissions and memory_cache_attribute functions.

On README.
 - memory regions
 - memory status
 - shared memory

What's in the example:
p0 - get memory id and status, print it, get (?) permissions and cache attribute
p1 - get memory id and status, print it, get (?) permissions and cache attribute
p0 - write to shared memory
p1 - read from shared memory
p0 - read from shared memory
p1 - write to shared memory

=== Exercise O ===

Exercises about events

enable_port_activity_irq

    /* enable port activity IRQ */
    bare_isr_install_handler(XKY_IRQ_PORT_ACTIVITY, (bare_isr_handler_f)port_activity);


=== Exercise P (MODULE_7 and MODULE_8) ===

Stuff related to ethernet. We should go over this, but seem a bit complex to 
do an exercise on this.