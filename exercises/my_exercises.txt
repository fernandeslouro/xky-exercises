
=== Exercises to add ===

 - Related to permissions/changes in permissions
 - Partition lifecycle (cold, warm, etc)
 - Exercise to test limits
 -


=== Exercise ===

For our first exercise, the goal is to get comfortable with the workflow of 
running xky applications on the boards connected to our server (Phantom).

When a board is powered up, it is programmed to try a TFTP boot. What this means
is that when it is powered on, it will look for a file with a specific name on
the TFPT server at 192.168.0.2 and it will boot this file.

For this exercise, you should not concern yourself with the application being 
loaded. We simply want to look at the serial output of our boards, and them
perform a power cycle so that the binary is booted by the board, and we can see
the output

1. Run "screen /opt/shortc/<your_board_name> 115200"
2. While maintaining the first terminal window open, run 
      "ima_powerctrl cycle <your_power_line_number>"
3. What do you see on the serial output window?

Additionally: Try editing a file in phantom


=== Exercise ===

In the previous exercise, we ran a previously compiled application on a boards,
which was already placed on the TFTP server. Now, we will be learning the whole
flow, from compiling an application, moving it to the tftp server, and rebooting
the board, so that it boots the new app in the tftp server.

1. Start by compiling the XKY application
2. Move the application to the TFTP server
3. See what is happening with your board, running the screen command
4. Run the powerctlr cycle command with your power line so that the board reboots
5. Exit screen :^)


=== Exercise B ===

So far, we have only compiled applications we did not write. In this exercise, we
want to build a very simple XKY application. This app should have a single partition,
which only prints "Hello World!" and then if should exit. 

You should start writing this application based on the boilerplate code in the
folder "boilerplate app". Other apps we will write on this course will all be
based on this one.

1. Create the necessary files, but leave them empty
2. Write the XML file for the application
3. Write the XML file for the partition
4. Write the C code with "hello world"


=== Exercise C ===

We now want to develop a slightly more complex application. The questions below
will guide you through developing an application of increasing complexity, 
while introducing you to the use of different XKY concepts.

Introduced concepts:
 - using several partitions

1. Implement the same application, but now printing a message in two partitions. 
2. Now change the functions so that the prints run on endless loops. 


=== Exercise D ===

What if we don't want to run the prints this many times, but we still want them 
to run in every schedule? XKY has this capablity

Introduced concepts:
 - mtf events stuff
 - partition running times

1. Now make each print once every MTF. Use the function wait_in_next_mtf.
2. Now make partitions take half as long a time to run
3. Some more complex stuff with MTFs


=== Exercise E ===



Introduced concepts:
 - schedules

1. Now add a third partition, making partitions run as 1 2 3 1 2 3.
2. Change the schedule to run as 1 2 1 3 1 2 1 3


=== Exercise ===

Implement an exercise about bare_wake_in_next_mtf

Functions to use:
 - bare_wake_in_next_mtf

A bunch of different prints every time a time frame runs.

=== Exercise (MODULE_0) ===

This exercise is about accessing information about partitions partitions , as well
as changing the current state of partitions

Some functions you should use during this exercise:
 - get_partition_id
 - get_partition_status
 - set_partition_mode
 - bare_wake_next_mtf
 - permissions on accessing other partition mode and status

Impement the following sequence of commands:
 - ts1 P1 Gets is own ID and Status and print it
 - ts2 P2 Gets is own ID and Status and print it
 - ts3 P1 Gets P2 ID and status and print it
 - ts4 P2 Gets P1 ID and status and print it
 - ts5 P1 Sets P2 to IDLE, prints P2 status, and the set is own state to IDLE
 - Both partitions should be stopped


=== Exercise (MODULE_1) ===

In this exercise, we will be using XKY's functions to get information about the
current schedule

Functions to be used:
 - get_schedule_id
 - get_schedule_status
 - set_module_schedule
 - set_schedule
 - permissions on changing the module schedule

Easy:
 - just run get_schedule_id and get_schedule status

Their exercise:
 - P1 from time window to time window changes what it does using bare_wake_in_next_mtf
	1. Prints schedule ID (though: should also add schedule_status, check feasibility)
	2. Changes schedule 
 - P2 and P3 Prints schedule ID 

=== Exercise (MODULE_2) ===

Functions to use:
 - bare_isr_handler_f
 - bare_isr_install_handler

On the Readme:
      scheduling events without polling the schedule status 
      does the same of the previous module but using events (similar timings)

Their exercise:
 - Change the preview example to use events instead of the bare_wake_in_next_mtf

=== Exercise (MODULE_3 and MODULE_4)===

Functions to use:
 - get_timer_tps
 - start_timer
 - get_elapsed_time

On the README:
      partition timers
      diferent timer expiration per partition
      timer events

Their exercise:
 - Set 4 Different timers for each partition, that will trigger an event that will print Global time , Local Time and the information of which timer was reached 
 - TODO: specify exactly the timers to set in the exercise

=== Exercise 5 (MODULE_5)===

Functions to use:
 - get_port_id
 - get_port_status
 - flush_port
 - read_port
 - write_port

Exercise about Queuing ports
      port status
      read/write queuing ports and message status
      port flush

My idea:
1.Declare queing port
2. Print port status
3. Send messages across a queuing port
4. Flush port

Their exercise:
 - P1 initially gets port ID, and prints the port status, after that, : 
	1. Sends a number of messages less than MaxNbMessages
	2. Sends a message smaller than MaxMessageSize
 - P2 initially gets port ID, and prints the port status, after that, each time window :
	1. Read all words on port and checks if is overflowed
	2. Read message and check if the message size overflowed
And then:
 - Now change the partition P1 to
	1. Sends more messages than MaxNbMessages
	2. Sends a message larger than MaxMessageSize
 - Verify that the previous verifications at P2 are working properly

=== Exercise 6 (MODULE_6) ===

Exercise about Queuing ports
      port status
      read/write samplind ports and message status

My idea:
1. Declare sampling port
2. Print port status
3. Send messages across a sampling port

Their exercise:
 - Change the previous example to use sampling ports. Check the validity of the read message


=== Exercise 7 ===

Exercises about memory

On README.
 - memory regions
 - memory status
 - shared memory

1. Create proper memories, shared memory between two partitions
2. Check memory regions you have
3. Send message across shared memory regions
4. Now send another, larger message that makes you have to increase memory size.


=== Exercise 8 ===

Exercises about events

enable_port_activity_irq

    /* enable port activity IRQ */
    bare_isr_install_handler(XKY_IRQ_PORT_ACTIVITY, (bare_isr_handler_f)port_activity);

=== Exercise (MODULE_7 and MODULE_8) ===


Stuff related to ethernet. We should go over this, but seem a bit complex to 
do an exercise on this.